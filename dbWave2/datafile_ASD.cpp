// ASDFile.cpp : implementation file
//

// ASDFile.cpp : implementation file
//

#include "stdafx.h"
#include "dataheader_Atlab.h"
#include "datafile_ASD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define DT_WAVE			0x01
#define DT_SPIKE		0x02
#define DT_HISTOGRAM	0x04
#define DT_ASCIITEXT	0x08
#define DT_RICHTEXT		0x10

// Macros to swap from Big Endian to Little Endian
#define SWAPWORD(x) MAKEWORD( HIBYTE(x), LOBYTE(x))
#define SWAPLONG(x) MAKELONG( SWAPWORD(HIWORD(x)), SWAPWORD(LOWORD(x)) )


/////////////////////////////////////////////////////////////////////////////
// CDataFileASD

IMPLEMENT_DYNCREATE(CDataFileASD, CDataFileX)

CDataFileASD::CDataFileASD()
{
	m_idType= DOCTYPE_ASDSYNTECH;
	m_csType= _T("ASDsyntech");
	m_csOldStringID = "AutoSpike 97 Data File";
	m_csStringID = "AutoSpike-32 Data File";
	m_wID = 0xAAAA;
	m_ulOffsetHeader = 29;
}


CDataFileASD::~CDataFileASD()
{
}


/////////////////////////////////////////////////////////////////////////////
// CDataFileASD diagnostics

#ifdef _DEBUG
void CDataFileASD::AssertValid() const
{
	CDataFileX::AssertValid();
}

void CDataFileASD::Dump(CDumpContext& dc) const
{
	CDataFileX::Dump( dc );	
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CDataFileASD commands

/**************************************************************************
 function:   read_data
 purpose:    read data from an file generated by ASD 
 parameters:
 returns:
 comments: 
 modif 04-04-96: read asyst file 1987 - add trap nb_subfiles
				 arbitrary set parameters: rate et gain 
				 - modify document classes from aWave
 **************************************************************************/

BOOL CDataFileASD::ReadDataInfos(CWaveFormat* pWFormat, CWaveChanArray* pArray)
{
	Seek(29, CFile::begin);			// position pointer
	CString csName;
	char ch= ' ';
	while (ch != 0)					// (1) signal name
	{
		Read(&ch, sizeof(char));
		if (ch != 0) csName += ch;
	}

	DWORD dw;
	WORD  w;
	DWORD recFactor;							// (3) external amplification factor
	Read(&dw, sizeof(DWORD));
	recFactor= SWAPLONG(dw);
	short gainpost = (short) recFactor;			// max is 32768
	short gainpre  = 1;
	ASSERT(recFactor <= 32768);

	double sampleRate;							// (4) sampling rate
	Read(&dw, sizeof(DWORD));
	sampleRate = (double) SWAPLONG(dw) / 1000.0;

	DWORD count;								// (5) number of correction factors
	Read(&dw, sizeof(DWORD));
	count= SWAPLONG(dw);

	DWORD index;
	int percent;
	long time;
	for (index=0; index < count; index++)		// (6-7) percent and time
	{
		Read(&w, sizeof(WORD));
		percent = SWAPWORD(w);
		Read(&dw, sizeof(DWORD));
		time = SWAPLONG(dw);
	}

	UINT uicount=0;								// (8) number of record samples
	Read(&dw, sizeof(DWORD));
	uicount= SWAPLONG(dw);

	ULONGLONG lOffset1 = GetPosition();			// start of data area
	m_ulOffsetData = lOffset1+1;
	ULONGLONG lOffset2 = ULONGLONG(uicount)*2;				// length of data area (in bytes)
	Seek(lOffset2, CFile::current);				// position pointer

	WORD checkSum;								// data end
	Read(&w, sizeof(WORD));
	checkSum = SWAPWORD(w);

	// tag 0xAAAA
	WORD wType;
	Read(&w, sizeof(WORD));						// read type
	wType = SWAPWORD(w);
	ASSERT(wType == m_wID);

	// file subtype
	Read(&w, sizeof(WORD));						// file subtype
	wType = SWAPWORD(w);
	ASSERT(wType == DT_ASCIITEXT);

	// read comment
	CString csComment;							// and now text comment
	do
	{
		Read(&ch, sizeof(char));
		if (ch != 0) csComment += ch;
	} while (ch != 0);

	Seek(lOffset1, CFile::begin);	// position pointer / beginning data
	pWFormat->scan_count=1;			// assume 1 channel

	// ---------------- specifics from Syntech A/D card
	pWFormat->fullscale_Volts = 10.0f;	// 10 mv full scale
	pWFormat->binspan = 32768;			// 15 bits resolution
	pWFormat->binzero = pWFormat->binspan/2 ;	// ?

	pWFormat->mode_encoding = OLx_ENC_BINARY;
	pWFormat->mode_clock = INTERNAL_CLOCK;
	pWFormat->mode_trigger = INTERNAL_TRIGGER;    
	pWFormat->chrate = (float) sampleRate;
	pWFormat->sample_count = uicount;	

	//for (i = 0; i<pWFormat->scan_count; i++)
	//{
	int i=0;
	pArray->ChannelAdd();
	CWaveChan* pChan = (CWaveChan*) pArray->GetWaveChan(i);
	pChan->am_csComment=CString(" ");					// channel annotation
	pChan->am_adchannel=0;								// channel scan list
	pChan->am_gainAD=1;									// channel gain list
	pChan->am_csamplifier= CString("syntechAmplifier");		// amplifier type
	pChan->am_csheadstage = CString("syntechProbe");	// headstage type
	pChan->am_gainheadstage=10;							// assume headstage gain = 10
	pChan->am_amplifierchan = 0;						// assume 1 channel / amplifier
	pChan->am_gainpre = gainpre;						// assume gain -pre and -post set before
	pChan->am_gainpost = gainpost;	
	pChan->am_notchfilt=0;								// assume no notch filter
	pChan->am_lowpass = 0;								// assume not low pass filtering
	pChan->am_offset= 0.0f;								// assume no offset compensation
	pChan->am_csInputpos = "25";
	pChan->am_csInputneg = "GND";
	pChan->am_gainamplifier = (float) recFactor;

	pChan->am_gaintotal = pChan->am_gainamplifier * pChan->am_gainheadstage;		// total gain
	pChan->am_resolutionV = pWFormat->fullscale_Volts / pChan->am_gaintotal / pWFormat->binspan;
	//}

	// ---------------- ASD -- capture date and time

	int strlen = csComment.GetLength();
	int ichar1 = 12;

	// month
	CString dummy = csComment.Mid(ichar1, 3);
	CString csmonth[] = 
	{ 
		_T("Jan"), _T("Feb"), _T("Mar"), _T("Apr"), _T("May"), _T("Jun"),
		_T("Jul"), _T("Aug"), _T("Sep"), _T("Oct"), _T("Nov"), _T("Dec")
	};

	int imonth=0;
	for (imonth = 0; imonth< 12; imonth++)
	{
		if (dummy.CompareNoCase(csmonth[imonth]) == 0)
			break;
	}
	imonth++;

	// day
	ichar1 += 4;
	dummy = csComment.Mid(ichar1, 2);
	int iday = _ttoi(dummy);

	// time
	ichar1 += 3;	
	int ihour = _ttoi(csComment.Mid(ichar1, 2));
	ichar1 += 3;
	int imin =  _ttoi(csComment.Mid(ichar1, 2));
	ichar1 += 3;
	int isec =  _ttoi(csComment.Mid(ichar1, 2));
	ichar1 += 3;
	int iyear = _ttoi(csComment.Mid(ichar1, 4));

	pWFormat->acqtime = CTime(iyear, imonth, iday, ihour, imin, isec);

	// Date  : Thu Nov 01 17:45:24 2001
	// insect -> Jf#8 
	// type -> 5th 2
	// stimulus -> Uma 0.05g, 10% EtOH, 20mM NaCl

	char od = 0xd;	
	ichar1 = csComment.Find(_T("Pretrigger"));
	ichar1 = csComment.Find(od, ichar1) +2;
	short ichar2 = csComment.Find(od, ichar1) +1;
	pWFormat->csInsectname = csComment.Mid(ichar1, ichar2 - ichar1 -1);
	
	ichar1=  ichar2 +1;
	ichar2 = csComment.Find(od, ichar1) +1;
	pWFormat->csSensillum = csComment.Mid(ichar1, ichar2 - ichar1 -1);

	pWFormat->csStimulus = csComment.Mid(ichar2+1, strlen -1);

	pWFormat->csComment.Empty();
	pWFormat->csConcentration.Empty();	

	return DOCTYPE_ASDSYNTECH;
}


BOOL CDataFileASD::CheckFileType(CFile* f, int bOffsetHeader)
{
	// position pointer to start of file
	f->Seek(0L, CFile::begin);

	// create archive to overload file operations
	BOOL	flag = DOCTYPE_UNKNOWN;
	WORD	wType;
	
	// (1) read data identification string
	int		iLEN=32;
	char	buf[32];
	char*	pbuf;
	pbuf= &buf[0];
	int i = 0;
	do
	{
		f->Read(pbuf, sizeof(char));
		pbuf++;
		iLEN--;
	} while (*(pbuf-1) != 0 && iLEN > 0);

	// is it an ASD file?
	if (buf != m_csOldStringID && buf != m_csStringID)
		return flag;

	// (2) file version number
	f->Read(&wType, sizeof(WORD));				
	wType = SWAPWORD(wType);
	if (wType != 1)
	{
		AfxMessageBox(_T("Incorrect ID word in ASD file"));
		return flag;
	}

	// browse file and get list of data type chunks
	ULONGLONG filelength = f->GetLength() -1;
	ULONGLONG offset = f->GetPosition();
	DWORD dw;
	WORD  w;

	while (f->GetPosition() < filelength) 
		{

		// read tag / "new data block"
		f->Read(&wType, sizeof(WORD));
		wType = SWAPWORD(wType);
		ASSERT(wType == m_wID);			// assert tag = 0xAAAA

		// check file type
		f->Read(&wType, sizeof(WORD));	// (4) file version number
		wType = SWAPWORD(wType);

		switch (wType)
		{
		case DT_WAVE:
			{
			flag = DOCTYPE_ASDSYNTECH;
			m_ulOffsetHeader = f->GetPosition();

			// (1) signal name
			CString csName;
			char ch= ' ';
			while (ch != 0)							
			{
				f->Read(&ch, sizeof(char));
				if (ch != 0) csName += ch;
			}

			DWORD recFactor;						// (3) external amplification factor
			f->Read(&dw, sizeof(DWORD));
			recFactor= SWAPLONG(dw);
			short gainpost = (short) recFactor;		// max is 32768
			short gainpre  = 1;
			ASSERT(recFactor <= 32768);

			double sampleRate;						// (4) sampling rate
			f->Read(&dw, sizeof(DWORD));
			sampleRate = (double) SWAPLONG(dw) / 1000.0;

			DWORD count;							// (5) number of correction factors
			f->Read(&dw, sizeof(DWORD));
			count= SWAPLONG(dw);

			DWORD index;
			int percent;
			long time;
			for (index=0; index < count; index++)	// (6-7) percent and time
			{
				f->Read(&w, sizeof(WORD));
				percent = SWAPWORD(w);
				f->Read(&dw, sizeof(DWORD));
				time = SWAPLONG(dw);
			}

			UINT uicount=0;							// (8) number of record samples
			f->Read(&dw, sizeof(DWORD));
			uicount= SWAPLONG(dw);

			ULONGLONG lOffset1 = f->GetPosition();		// start of data area
			m_ulOffsetData = lOffset1+1;
			ULONGLONG lOffset2 = ULONGLONG(uicount)*2;				// length of data area (in bytes)
			f->Seek(lOffset2, CFile::current);		// position pointer

			WORD checkSum;							// data end
			f->Read(&w, sizeof(WORD));
			checkSum = SWAPWORD(w);
			}
			break;

		case DT_SPIKE:
		case DT_HISTOGRAM:
		case DT_ASCIITEXT:
		case DT_RICHTEXT:
			{
				WORD w = 0;
				do
				{
					f->Read(&w, sizeof(WORD));
					wType = SWAPWORD(w);
				}
				while (w != m_wID && f->GetPosition() < filelength);	
				// 0xAAAA
				if (w == m_wID)
				{
					LONGLONG lpos = f->GetPosition() - 2;
					f->Seek(lpos, CFile::begin);
				}
			}
			break;
		default:
			//m_ulOffsetHeader = 0;
			AfxMessageBox(_T("Data type not supported yet"));
			break;
		}
	} 

	return flag;
}